Адаптируйте указанные сущности под выбранную вами тематику.
Обязательно сохраните связь между Пользователями, и N сущностями другого типа.
Роботы и Монстры в нашем приложении очень похожи, однако наличие обоих
позволяет лучше видеть места, где код будет "разрастаться" при появлении
новых моделей (типов). Что позволяет правильнее структурировать файлы
и папки и распределить код между ними.

Три таблицы: пользователи, спектакили и комментарии
Users {
  id: Id,
  role: UserRole, // enums.of("viewer", "actor", "director", "admin")
  userName: String,
  inclusionDate: Date,
  exclusionDate: Date,
  countOfPerfomance: Integer
}

Perfomance {
  id: Integer,
  title: String,
  description: String,
  actorsCount: Integer,
  premiereDate: Date,
  closingDate: Date,
  visitors: Integer,
  rating: Float,
  commentCount: Integer
}

PerfomanceComment {
  id: Id,
  perfimanceId: Id,
  formUserId: Id,
  toUserId: Id,
  text: String,
  createdIn: Date,
  editedOn: Date
}

Связи:
Актер - спектакль: n - m
Режиссер - спектакль: 1 - n
Зритель - спектакль (рейтинг посетитель): n - m
Спектакль - комментарий: 1 - n




В нашем демо-приложении имеются три типа сущностей: Пользователи, Роботы и Монстры.
Каждый пользователь владеет одним или более Роботом и Монстром.
В случае реляционных БД мы задумались бы о первичных и внешних ключах.
Какие таблицы нам нужны? Какова их структура? Хорошая новость – всё это актуально и для эмуляции.

Таблицы могут быть представлены в виде массивов. Строки и записи – в виде объектов.
 Переменные на уровне модуля – могут хранить состояние между запросами. "Подключение к БД" не требуется.

В этой теоретической задаче требуется продумать структуру "таблиц" базы данных.

Теоретическая задача:
Три таблицы: Пользователи, Ромботы и Монстры.
Пользователь {
  id: Integer,
  Имя: String,
  Фамилия: String || ""
}
Робот {
  id: Integer,
  Название: String,
  Владелец: Integer
}
Монстр {
  id: Integer,
  Название: String,
  Владелец: Integer
}
Связи
Пользователи - Роботы: 1 - n
Пользователи - Монстры: 1 - n
